import { toArray, first, map, find } from 'iterable-operator';
import { isntUndefined } from 'extra-utils';
class TreeNode {
    value;
    children = new Map();
    constructor(value) {
        this.value = value;
    }
}
export class RadixTree {
    root = new TreeNode();
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    entries() {
        return dfs(this.root, []);
        function* dfs(node, path) {
            for (const [prefix, childNode] of node.children) {
                const newPath = [...path, ...prefix];
                if (isntUndefined(childNode.value)) {
                    yield [newPath, childNode.value];
                }
                yield* dfs(childNode, newPath);
            }
        }
    }
    keys() {
        return map(this.entries(), ([key]) => key);
    }
    values() {
        return map(this.entries(), ([, value]) => value);
    }
    set(key, value) {
        set(toArray(key), value, this.root);
        return this;
        function set(key, value, node) {
            const commonPrefix = findCommonPrefix(node.children.keys(), key);
            if (isntUndefined(commonPrefix)) {
                const { prefix, commonPartLength } = commonPrefix;
                if (prefix.length === commonPartLength) {
                    const prefixNode = node.children.get(prefix);
                    if (key.length === prefix.length) {
                        prefixNode.value = value;
                    }
                    else {
                        const newKey = key.slice(prefix.length);
                        set(newKey, value, prefixNode);
                    }
                }
                else {
                    const oldPrefixNode = node.children.get(prefix);
                    const commonPrefix = prefix.slice(0, commonPartLength);
                    const newPrefixNode = new TreeNode();
                    node.children.set(commonPrefix, newPrefixNode);
                    newPrefixNode.children.set(prefix.slice(commonPartLength), oldPrefixNode);
                    newPrefixNode.children.set(key.slice(commonPartLength), new TreeNode(value));
                    node.children.delete(prefix);
                }
            }
            else {
                node.children.set(key, new TreeNode(value));
            }
        }
    }
    has(key) {
        return has(toArray(key), this.root);
        function has(key, node) {
            const matchedPrefix = matchPrefix(node.children.keys(), key);
            if (isntUndefined(matchedPrefix)) {
                const restKey = key.slice(matchedPrefix.length);
                if (restKey.length === 0) {
                    return true;
                }
                else {
                    return has(restKey, node.children.get(matchedPrefix));
                }
            }
            else {
                return false;
            }
        }
    }
    get(key) {
        return get(toArray(key), this.root);
        function get(key, node) {
            const matchedPrefix = matchPrefix(node.children.keys(), key);
            if (isntUndefined(matchedPrefix)) {
                const restKey = key.slice(matchedPrefix.length);
                const nextNode = node.children.get(matchedPrefix);
                if (restKey.length === 0) {
                    return nextNode.value;
                }
                else {
                    return get(restKey, nextNode);
                }
            }
            else {
                return undefined;
            }
        }
    }
    delete(key) {
        return _delete(toArray(key), this.root);
        function _delete(key, node) {
            const matchedPrefix = matchPrefix(node.children.keys(), key);
            if (isntUndefined(matchedPrefix)) {
                if (key.length === matchedPrefix.length) {
                    const targetNode = node.children.get(matchedPrefix);
                    if (targetNode.children.size === 0) {
                        node.children.delete(matchedPrefix);
                    }
                    else {
                        node.value = undefined;
                        if (targetNode.children.size === 1) {
                            const [key, value] = first(targetNode.children.entries());
                            node.children.set([...matchedPrefix, ...key], value);
                            node.children.delete(matchedPrefix);
                        }
                    }
                    return true;
                }
                else {
                    const nextNode = node.children.get(matchedPrefix);
                    const nextKey = key.slice(matchedPrefix.length);
                    const deleted = _delete(nextKey, nextNode);
                    if (deleted) {
                        if (!('value' in nextNode)) {
                            switch (nextNode.children.size) {
                                case 0: {
                                    node.children.delete(matchedPrefix);
                                    break;
                                }
                                case 1: {
                                    const [key, value] = first(nextNode.children.entries());
                                    node.children.set([...matchedPrefix, ...key], value);
                                    node.children.delete(matchedPrefix);
                                    break;
                                }
                                default: {
                                    const entries = toArray(nextNode.children.entries());
                                    const keys = entries.map(([key]) => key);
                                    const commonPrefix = getCommonPrefix(keys);
                                    if (commonPrefix) {
                                        const newPrefix = [...matchedPrefix, ...commonPrefix];
                                        const childNode = new TreeNode();
                                        for (const [key, value] of entries) {
                                            childNode.children.set(key.slice(commonPrefix.length), value);
                                        }
                                        node.children.set(newPrefix, childNode);
                                        node.children.delete(matchedPrefix);
                                    }
                                }
                            }
                        }
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }
            else {
                return false;
            }
        }
    }
}
export function matchPrefix(prefixes, path) {
    return find(prefixes, prefix => path[0] === prefix[0]);
}
export function findCommonPrefix(prefixes, path) {
    for (const prefix of prefixes) {
        let commonPartLength = 0;
        for (let i = 0; i < prefix.length; i++) {
            if (path[i] === prefix[i]) {
                commonPartLength++;
            }
            else {
                if (commonPartLength > 0) {
                    return { prefix, commonPartLength };
                }
            }
        }
        if (commonPartLength > 0) {
            return { prefix, commonPartLength };
        }
    }
}
export function getCommonPrefix(paths) {
    if (paths.length > 0) {
        const commonPrefix = [];
        loop: for (let elementIndex = 0, firstPathLength = paths[0].length; elementIndex < firstPathLength; elementIndex++) {
            const element = paths[0][elementIndex];
            for (let pathIndex = 1; pathIndex < paths.length; pathIndex++) {
                const path = paths[pathIndex];
                if (elementIndex < path.length) {
                    if (path[elementIndex] !== element) {
                        break loop;
                    }
                }
                else {
                    break loop;
                }
            }
            commonPrefix.push(element);
        }
        return commonPrefix;
    }
    else {
        return [];
    }
}
//# sourceMappingURL=radix-tree.js.map