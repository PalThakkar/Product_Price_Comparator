import { assert } from '@blackglory/errors';
import { first } from 'iterable-operator';
import { setSchedule } from 'extra-timers';
export class TLRUMap {
    limit;
    map = new Map();
    cancelClearTimeout;
    itemMetadataSortedByExpirationTime = [];
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    get size() {
        return this.map.size;
    }
    constructor(limit) {
        assert(Number.isInteger(limit), 'The parameter limit must be an integer');
        assert(limit > 0, 'The parameter limit must be a positive value');
        this.limit = limit;
    }
    set(key, value, timeToLive = Infinity) {
        if (this.map.has(key)) {
            this.updateItem(key, value);
            this.removeItemMetadata(key);
            this.addItemMetadata(key, Date.now() + timeToLive);
        }
        else {
            if (this.map.size === this.limit) {
                this.map.delete(this.getColdestKey());
            }
            this.map.set(key, value);
            this.addItemMetadata(key, Date.now() + timeToLive);
        }
        return this;
    }
    has(key) {
        return this.map.has(key);
    }
    get(key) {
        if (this.has(key)) {
            const value = this.map.get(key);
            this.updateItem(key, value);
            return value;
        }
        else {
            return undefined;
        }
    }
    delete(key) {
        const result = this.map.delete(key);
        if (result) {
            const index = this.itemMetadataSortedByExpirationTime.findIndex(x => x.key === key);
            this.itemMetadataSortedByExpirationTime.splice(index, 1);
            if (index === 0) {
                this.rescheduleClearTimeout();
            }
        }
        return result;
    }
    clear() {
        this.map.clear();
        this.cancelClearTimeout?.();
        this.itemMetadataSortedByExpirationTime = [];
    }
    updateItem(key, value) {
        this.map.delete(key);
        this.map.set(key, value);
    }
    addItemMetadata(key, expirationTime) {
        for (let i = 0; i < this.itemMetadataSortedByExpirationTime.length; i++) {
            const item = this.itemMetadataSortedByExpirationTime[i];
            if (expirationTime < item.expirationTime) {
                this.itemMetadataSortedByExpirationTime.splice(i, 0, { key, expirationTime });
                if (i === 0) {
                    this.rescheduleClearTimeout();
                }
                return;
            }
        }
        this.itemMetadataSortedByExpirationTime.push({ key, expirationTime });
        if (this.itemMetadataSortedByExpirationTime.length === 1) {
            this.rescheduleClearTimeout();
        }
    }
    removeItemMetadata(key) {
        const index = this.itemMetadataSortedByExpirationTime.findIndex(x => x.key === key);
        if (index >= 0) {
            this.itemMetadataSortedByExpirationTime.splice(index, 1);
            if (index === 0) {
                this.rescheduleClearTimeout();
            }
        }
    }
    clearExpiredItems(timestamp) {
        const indexOfFirstUnexpiredItem = this.itemMetadataSortedByExpirationTime.findIndex(x => x.expirationTime > timestamp);
        const expiredItemKeys = indexOfFirstUnexpiredItem >= 0
            ? this.itemMetadataSortedByExpirationTime.splice(0, indexOfFirstUnexpiredItem)
            : this.itemMetadataSortedByExpirationTime.splice(0, this.itemMetadataSortedByExpirationTime.length);
        expiredItemKeys.forEach(x => this.map.delete(x.key));
    }
    rescheduleClearTimeout() {
        this.cancelClearTimeout?.();
        if (this.itemMetadataSortedByExpirationTime.length > 0) {
            const item = this.itemMetadataSortedByExpirationTime[0];
            if (Number.isFinite(item.expirationTime)) {
                const cancel = setSchedule(item.expirationTime, () => {
                    this.clearExpiredItems(Date.now());
                    this.rescheduleClearTimeout();
                });
                this.cancelClearTimeout = () => {
                    cancel();
                    this.cancelClearTimeout = undefined;
                };
            }
        }
    }
    getColdestKey() {
        return first(this.map.keys());
    }
}
//# sourceMappingURL=tlru-map.js.map