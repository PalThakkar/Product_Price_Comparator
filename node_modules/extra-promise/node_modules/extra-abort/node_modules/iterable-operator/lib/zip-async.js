import { isAsyncIterable } from "./is-async-iterable.js";
var Kind;
(function (Kind) {
    Kind[Kind["Sync"] = 0] = "Sync";
    Kind[Kind["Async"] = 1] = "Async";
})(Kind || (Kind = {}));
export function zipAsync(iterable, ...otherIterables) {
    return _zipAsync(iterable, ...otherIterables);
}
async function* _zipAsync(...iterables) {
    var _a, _b, _c, _d;
    const length = iterables.length;
    const iterators = iterables.map(iterable => {
        if (isAsyncIterable(iterable)) {
            return [Kind.Async, iterable[Symbol.asyncIterator]()];
        }
        else {
            return [Kind.Sync, iterable[Symbol.iterator]()];
        }
    });
    const dones = iterators.map(() => false);
    try {
        while (true) {
            const result = new Array(length);
            for (let i = 0; i < length; i++) {
                const [kind, iterator] = iterators[i];
                let temp;
                if (kind === Kind.Async) {
                    temp = await iterator.next();
                }
                else {
                    temp = iterator.next();
                }
                if (temp.done) {
                    dones[i] = true;
                    return;
                }
                result[i] = await temp.value;
            }
            yield result;
        }
    }
    finally {
        const undoneIterators = iterators.filter((_, i) => !dones[i]);
        for (const [kind, iterator] of undoneIterators) {
            if (kind === Kind.Async) {
                await ((_b = (_a = iterator).return) === null || _b === void 0 ? void 0 : _b.call(_a));
            }
            else {
                (_d = (_c = iterator).return) === null || _d === void 0 ? void 0 : _d.call(_c);
            }
        }
    }
}
//# sourceMappingURL=zip-async.js.map