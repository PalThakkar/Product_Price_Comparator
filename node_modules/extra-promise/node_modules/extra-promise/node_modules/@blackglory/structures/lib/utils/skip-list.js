import { isntNull } from 'extra-utils';
export class SkipListNode {
    constructor(value) {
        this.value = value;
        this.previous = null;
        this.next = null;
        this.up = null;
        this.down = null;
    }
}
export class SkipList {
    constructor(compare) {
        this.compare = compare;
        this.head = new SkipListNode(null);
        this.tail = new SkipListNode(null);
        this.height = 0;
        this._size = 0;
        this.head.next = this.tail;
        this.tail.previous = this.head;
    }
    get size() {
        return this._size;
    }
    *elements() {
        let currentNode = this.head;
        while (currentNode.down) {
            currentNode = currentNode.down;
        }
        while (currentNode.next && isntNull(currentNode.next.value)) {
            currentNode = currentNode.next;
            yield currentNode;
        }
    }
    dumpList() {
        const result = [];
        let head = this.head;
        do {
            result.push([]);
            let currentNode = head;
            do {
                result[result.length - 1].push(currentNode.value);
                currentNode = currentNode.next;
            } while (currentNode);
        } while (head = head.down);
        return result;
    }
    delete(value) {
        let currentNode = this.findNode(value);
        while (currentNode) {
            currentNode.previous.next = currentNode.next;
            currentNode.next.previous = currentNode.previous;
            currentNode = currentNode.down;
        }
        this._size--;
    }
    has(value) {
        return isntNull(this.findNode(value));
    }
    findNode(value) {
        let currentNode = this.head;
        while (true) {
            while (currentNode.next && isntNull(currentNode.next.value)) {
                const result = this.compare(currentNode.next.value, value);
                if (result === 0) {
                    return currentNode.next;
                }
                else if (result < 0) {
                    currentNode = currentNode.next;
                }
                else {
                    break;
                }
            }
            if (currentNode.down) {
                currentNode = currentNode.down;
            }
            else {
                return null;
            }
        }
    }
    add(value) {
        let previousNode = this.findPreviousNode(value);
        if (previousNode.next &&
            isntNull(previousNode.next.value) &&
            this.compare(previousNode.next.value, value) === 0) {
            return;
        }
        let newNode = new SkipListNode(value);
        if (previousNode.next) {
            newNode.next = previousNode.next;
            previousNode.next.previous = newNode;
        }
        previousNode.next = newNode;
        newNode.previous = previousNode;
        let level = 0;
        while (Math.random() < 0.5) {
            if (level === this.height) {
                const newHead = new SkipListNode(null);
                const newTail = new SkipListNode(null);
                newHead.next = newTail;
                newHead.down = this.head;
                newTail.previous = newHead;
                newTail.down = this.tail;
                this.head.up = newHead;
                this.tail.up = newTail;
                this.head = newHead;
                this.tail = newTail;
                this.height++;
            }
            while (!previousNode.up) {
                previousNode = previousNode.previous;
            }
            previousNode = previousNode.up;
            const upperNewNode = new SkipListNode(value);
            if (previousNode.next) {
                upperNewNode.next = previousNode.next;
                previousNode.next.previous = upperNewNode;
            }
            previousNode.next = upperNewNode;
            upperNewNode.previous = previousNode;
            upperNewNode.down = newNode;
            newNode.up = upperNewNode;
            newNode = upperNewNode;
            level++;
        }
        this._size++;
    }
    findPreviousNode(value) {
        let currentNode = this.head;
        while (true) {
            while (currentNode.next && isntNull(currentNode.next.value)) {
                const result = this.compare(currentNode.next.value, value);
                if (result >= 0) {
                    break;
                }
                else {
                    currentNode = currentNode.next;
                }
            }
            if (currentNode.down) {
                currentNode = currentNode.down;
            }
            else {
                return currentNode;
            }
        }
    }
}
//# sourceMappingURL=skip-list.js.map