import { Deferred } from "./deferred.js";
import { Queue } from '@blackglory/structures';
import { FiniteStateMachine } from 'extra-fsm';
import { validateConcurrency } from "../utils/validate-concurrency.js";
import { LinkedAbortController, AbortController, withAbortSignal, AbortError } from 'extra-abort';
import { assert, CustomError } from '@blackglory/errors';
import { isUndefined, isFinite } from 'extra-utils';
import { delay } from "../functions/delay.js";
import { pass } from '@blackglory/pass';
export class TaskRunnerDestroyedError extends CustomError {
}
export class TaskRunner {
    constructor(concurrency = Infinity, rateLimit) {
        this.concurrency = concurrency;
        this.rateLimit = rateLimit;
        this.fsm = new FiniteStateMachine({
            running: {
                destroy: 'destroyed'
            },
            destroyed: {}
        }, 'running');
        this.queue = new Queue();
        this.runningTasks = new Set();
        this.schedule = async () => {
            if (this.scheduleController)
                return;
            const controller = new AbortController();
            this.scheduleController = controller;
            while (this.fsm.matches('running') &&
                !this.scheduleController.signal.aborted &&
                this.queue.size > 0 &&
                this.runningTasks.size < this.concurrency) {
                if (this.rateLimit) {
                    if (isUndefined(this.window) ||
                        (Date.now() - this.window.startTime) >= this.rateLimit.duration) {
                        this.window = {
                            startTime: Date.now(),
                            count: 0
                        };
                    }
                    if (this.window.count < this.rateLimit.limit) {
                        this.window.count++;
                        const item = this.queue.dequeue();
                        this.process(item);
                    }
                    else {
                        try {
                            await this.waitForNextWindow(controller.signal);
                        }
                        catch (e) {
                            if (e instanceof AbortError) {
                                pass();
                            }
                            else {
                                throw e;
                            }
                        }
                    }
                }
                else {
                    const item = this.queue.dequeue();
                    this.process(item);
                }
            }
            this.scheduleController = undefined;
        };
        validateConcurrency('concurrency', concurrency);
        if (rateLimit) {
            assert(isFinite(rateLimit.duration) && rateLimit.duration > 0, 'The parameter rateLimit.duration must be greater than zero');
            assert(isFinite(rateLimit.limit) && rateLimit.limit > 0, 'The parameter rateLimit.limit must be greater than zero');
        }
    }
    /**
     * @throws {TaskRunnerDestroyedError}
     */
    async run(fn, signal) {
        if (this.fsm.matches('destroyed'))
            throw new TaskRunnerDestroyedError();
        if (signal === null || signal === void 0 ? void 0 : signal.aborted)
            throw signal.reason;
        const deferred = new Deferred();
        const controller = signal
            ? new LinkedAbortController(signal)
            : new AbortController();
        const task = {
            fn,
            deferred,
            controller
        };
        this.queue.enqueue(task);
        signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', () => {
            deferred.reject(signal.reason);
            this.queue.remove(task);
        });
        this.schedule();
        return await deferred;
    }
    destroy() {
        var _a;
        this.fsm.send('destroy');
        (_a = this.scheduleController) === null || _a === void 0 ? void 0 : _a.abort();
        const error = new TaskRunnerDestroyedError();
        this.runningTasks.forEach(task => {
            task.controller.abort(error);
        });
        let task;
        while (task = this.queue.dequeue()) {
            task.deferred.reject(error);
        }
    }
    /**
     * @throws {AbortError}
     */
    async waitForNextWindow(signal) {
        assert(this.window);
        assert(this.rateLimit);
        const timeout = Math.max(this.rateLimit.duration - (Date.now() - this.window.startTime), 0);
        await withAbortSignal(signal, () => delay(timeout));
    }
    async process(task) {
        this.runningTasks.add(task);
        try {
            if (task.controller.signal.aborted)
                throw task.controller.signal.reason;
            const result = await task.fn(task.controller.signal);
            task.deferred.resolve(result);
        }
        catch (e) {
            task.deferred.reject(e);
        }
        this.runningTasks.delete(task);
        this.schedule();
    }
}
//# sourceMappingURL=task-runner.js.map