import { assert } from '@blackglory/errors';
export class DynamicTypedArray {
    constructor(typedArrayConstructor, { capacity = 0, growthFactor = 1.5 } = {}) {
        this.typedArrayConstructor = typedArrayConstructor;
        this._length = 0;
        assert(Number.isInteger(capacity), 'capacity must be an integer');
        assert(capacity >= 0, 'capacity must be greater than or equal to 0');
        assert(growthFactor >= 1, 'growthFactory must be greater than or equal to 1');
        this.initialCapacity = capacity;
        this.array = new typedArrayConstructor(capacity);
        this.growthFactor = growthFactor;
    }
    get internalTypedArray() {
        return this.array;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    get BYTES_PER_ELEMENT() {
        return this.typedArrayConstructor.BYTES_PER_ELEMENT;
    }
    get capacity() {
        return this.array.length;
    }
    get length() {
        return this._length;
    }
    set(index, value) {
        if (index >= this.capacity) {
            const newCapacity = computeNewCapacity(this.capacity, index + 1, this.growthFactor);
            this.resize(newCapacity);
        }
        if (index >= this._length) {
            this._length = index + 1;
        }
        this.array[index] = value;
    }
    setValues(index, values) {
        if (index + values.length >= this.capacity) {
            const newCapacity = computeNewCapacity(this.capacity, index + values.length, this.growthFactor);
            this.resize(newCapacity);
        }
        if (index + values.length > this._length) {
            this._length = index + values.length;
        }
        this.internalTypedArray.set(values, index);
    }
    get(index) {
        return index < this._length
            ? this.array[index]
            : undefined;
    }
    push(...values) {
        const newLength = this._length + values.length;
        if (newLength > this.capacity) {
            const newCapacity = computeNewCapacity(this.capacity, newLength, this.growthFactor);
            this.resize(newCapacity);
        }
        for (const value of values) {
            this.array[this._length++] = value;
        }
    }
    pop() {
        if (this._length > 0) {
            const value = this.array[this._length - 1];
            this._length--;
            const newCapacity = computeNewCapacity(this.capacity, this.length, this.growthFactor);
            this.resize(newCapacity);
            return value;
        }
        else {
            return undefined;
        }
    }
    clear() {
        this._length = 0;
        const newArray = new this.typedArrayConstructor(this.initialCapacity);
        this.array = newArray;
    }
    sort(compare) {
        const capacity = this.capacity;
        this.resize(this.length);
        this.array.sort(compare);
        this.resize(capacity);
    }
    resize(newCapacity) {
        if (this.array.length === newCapacity) {
            return;
        }
        else if (this.array.length < newCapacity) {
            const newArray = new this.typedArrayConstructor(newCapacity);
            newArray.set(this.array);
            this.array = newArray;
        }
        else if (this.array.length > newCapacity) {
            const newArray = new this.typedArrayConstructor(newCapacity);
            for (let i = newCapacity; i--;) {
                newArray[i] = this.array[i];
            }
            this.array = newArray;
        }
    }
}
export function computeNewCapacity(oldCapacity, targetLength, growthFactor) {
    if (growthFactor === 1) {
        return targetLength;
    }
    else {
        if (oldCapacity === targetLength) {
            return targetLength;
        }
        else if (oldCapacity < targetLength) {
            let newCapacity = Math.max(oldCapacity, 1);
            while (newCapacity < targetLength) {
                newCapacity *= growthFactor;
            }
            return Math.floor(newCapacity);
        }
        else {
            if (targetLength === 0) {
                return 0;
            }
            else {
                let newCapacity = oldCapacity;
                while (true) {
                    const temp = newCapacity / growthFactor;
                    if (temp < targetLength) {
                        break;
                    }
                    else {
                        newCapacity = temp;
                    }
                }
                return Math.floor(newCapacity);
            }
        }
    }
}
//# sourceMappingURL=dynamic-typed-array.js.map