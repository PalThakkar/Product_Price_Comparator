import { setSchedule } from 'extra-timers';
export class ExpirableMap {
    constructor() {
        this.map = new Map();
        this.itemMetadataSortedByExpirationTime = [];
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    get size() {
        return this.map.size;
    }
    set(key, value, timeToLive = Infinity) {
        this.map.set(key, value);
        this.removeItemMetadata(key);
        this.addItemMetadata(key, Date.now() + timeToLive);
        return this;
    }
    has(key) {
        return this.map.has(key);
    }
    get(key) {
        return this.map.get(key);
    }
    delete(key) {
        var _a;
        const exists = this.map.delete(key);
        if (exists) {
            const index = this.itemMetadataSortedByExpirationTime.findIndex(x => x.key === key);
            this.itemMetadataSortedByExpirationTime.splice(index, 1);
            if (index === 0) {
                (_a = this.cancelScheduledCleaner) === null || _a === void 0 ? void 0 : _a.call(this);
                this.scheduleCleaner();
            }
        }
        return exists;
    }
    clear() {
        var _a;
        this.map.clear();
        (_a = this.cancelScheduledCleaner) === null || _a === void 0 ? void 0 : _a.call(this);
        this.itemMetadataSortedByExpirationTime = [];
    }
    addItemMetadata(key, expirationTime) {
        var _a, _b;
        for (let i = 0; i < this.itemMetadataSortedByExpirationTime.length; i++) {
            const item = this.itemMetadataSortedByExpirationTime[i];
            if (expirationTime < item.expirationTime) {
                this.itemMetadataSortedByExpirationTime.splice(i, 0, { key, expirationTime });
                if (i === 0) {
                    (_a = this.cancelScheduledCleaner) === null || _a === void 0 ? void 0 : _a.call(this);
                    this.scheduleCleaner();
                }
                return;
            }
        }
        this.itemMetadataSortedByExpirationTime.push({ key, expirationTime });
        if (this.itemMetadataSortedByExpirationTime.length === 1) {
            (_b = this.cancelScheduledCleaner) === null || _b === void 0 ? void 0 : _b.call(this);
            this.scheduleCleaner();
        }
    }
    removeItemMetadata(key) {
        var _a;
        const index = this.itemMetadataSortedByExpirationTime.findIndex(x => x.key === key);
        if (index >= 0) {
            this.itemMetadataSortedByExpirationTime.splice(index, 1);
            if (index === 0) {
                (_a = this.cancelScheduledCleaner) === null || _a === void 0 ? void 0 : _a.call(this);
                this.scheduleCleaner();
            }
        }
    }
    scheduleCleaner() {
        if (this.itemMetadataSortedByExpirationTime.length > 0) {
            const item = this.itemMetadataSortedByExpirationTime[0];
            if (Number.isFinite(item.expirationTime)) {
                this.cancelScheduledCleaner = setSchedule(item.expirationTime, () => {
                    var _a;
                    this.clearExpiredItems(Date.now());
                    (_a = this.cancelScheduledCleaner) === null || _a === void 0 ? void 0 : _a.call(this);
                    this.scheduleCleaner();
                });
            }
        }
    }
    clearExpiredItems(timestamp) {
        const indexOfFirstUnexpired = this.itemMetadataSortedByExpirationTime.findIndex(x => x.expirationTime > timestamp);
        const expiredItemKeys = indexOfFirstUnexpired >= 0
            ? this.itemMetadataSortedByExpirationTime.splice(0, indexOfFirstUnexpired)
            : this.itemMetadataSortedByExpirationTime.splice(0, this.itemMetadataSortedByExpirationTime.length);
        expiredItemKeys.forEach(x => this.map.delete(x.key));
    }
}
//# sourceMappingURL=expirable-map.js.map