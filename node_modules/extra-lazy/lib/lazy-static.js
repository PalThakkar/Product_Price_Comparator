const contexts = [];
export function withLazyStatic(fn) {
    const cache = [];
    return (...args) => {
        contexts.push({ cache, index: 0 });
        try {
            return fn(...args);
        }
        finally {
            contexts.pop();
        }
    };
}
export function lazyStatic(getter, deps = []) {
    if (contexts.length) {
        const context = contexts[contexts.length - 1];
        const index = context.index++;
        const isFirstRun = index === context.cache.length;
        if (isFirstRun) {
            updateCache();
        }
        else {
            const oldDeps = context.cache[index].deps;
            if (deps.length === oldDeps.length) {
                if (deps.some((x, i) => x !== oldDeps[i])) {
                    updateCache();
                }
            }
            else {
                updateCache();
            }
        }
        const result = context.cache[index].value;
        return result;
        function updateCache() {
            context.cache[index] = null;
            context.cache[index] = {
                value: getter(),
                deps: Array.from(deps)
            };
        }
    }
    else {
        throw new Error('lazyStatic can only be called in the function wrapped by withlazyStatic.');
    }
}
//# sourceMappingURL=lazy-static.js.map