import { Level } from "./types.js";
import { getValue } from "./utils/get-value.js";
import { measureElapsedTime, measureElapsedTimeAsync } from "./utils/measure-elapsed-time.js";
export class Logger {
    constructor(options) {
        this.options = options;
    }
    trace(message, elapsedTime) {
        return this.logByLevel(Level.Trace, message, elapsedTime);
    }
    traceAsync(message, elapsedTime) {
        return this.logByLevelAsync(Level.Trace, message, elapsedTime);
    }
    info(message, elapsedTime) {
        return this.logByLevel(Level.Info, message, elapsedTime);
    }
    infoAsync(message, elapsedTime) {
        return this.logByLevelAsync(Level.Info, message, elapsedTime);
    }
    debug(message, elapsedTime) {
        return this.logByLevel(Level.Debug, message, elapsedTime);
    }
    debugAsync(message, elapsedTime) {
        return this.logByLevelAsync(Level.Debug, message, elapsedTime);
    }
    warn(message, elapsedTime) {
        return this.logByLevel(Level.Warn, message, elapsedTime);
    }
    warnAsync(message, elapsedTime) {
        return this.logByLevelAsync(Level.Warn, message, elapsedTime);
    }
    error(message, elapsedTime) {
        this.logByLevel(Level.Error, message, elapsedTime);
    }
    errorAsync(message, elapsedTime) {
        return this.logByLevelAsync(Level.Error, message, elapsedTime);
    }
    fatal(message, elapsedTime) {
        this.logByLevel(Level.Fatal, message, elapsedTime);
    }
    fatalAsync(message, elapsedTime) {
        return this.logByLevelAsync(Level.Fatal, message, elapsedTime);
    }
    traceTime(message, expression) {
        return this.logTimeByLevel(Level.Trace, message, expression);
    }
    traceTimeAsync(message, expression) {
        return this.logTimeByLevelAsync(Level.Trace, message, expression);
    }
    infoTime(message, expression) {
        return this.logTimeByLevel(Level.Info, message, expression);
    }
    infoTimeAsync(message, expression) {
        return this.logTimeByLevelAsync(Level.Info, message, expression);
    }
    debugTime(message, expression) {
        return this.logTimeByLevel(Level.Debug, message, expression);
    }
    debugTimeAsync(message, expression) {
        return this.logTimeByLevelAsync(Level.Debug, message, expression);
    }
    warnTime(message, expression) {
        return this.logTimeByLevel(Level.Warn, message, expression);
    }
    warnTimeAsync(message, expression) {
        return this.logTimeByLevelAsync(Level.Warn, message, expression);
    }
    errorTime(message, expression) {
        return this.logTimeByLevel(Level.Error, message, expression);
    }
    errorTimeAsync(message, expression) {
        return this.logTimeByLevelAsync(Level.Error, message, expression);
    }
    fatalTime(message, expression) {
        return this.logTimeByLevel(Level.Fatal, message, expression);
    }
    fatalTimeAsync(message, expression) {
        return this.logTimeByLevelAsync(Level.Fatal, message, expression);
    }
    traceTimeFunction(message, fn) {
        return this.logTimeFunctionByLevel(Level.Trace, message, fn);
    }
    traceTimeAsyncFunction(message, fn) {
        return this.logTimeAsyncFunctionByLevel(Level.Trace, message, fn);
    }
    infoTimeFunction(message, fn) {
        return this.logTimeFunctionByLevel(Level.Info, message, fn);
    }
    infoTimeAsyncFunction(message, fn) {
        return this.logTimeAsyncFunctionByLevel(Level.Info, message, fn);
    }
    debugTimeFunction(message, fn) {
        return this.logTimeFunctionByLevel(Level.Debug, message, fn);
    }
    debugTimeAsyncFunction(message, fn) {
        return this.logTimeAsyncFunctionByLevel(Level.Debug, message, fn);
    }
    warnTimeFunction(message, fn) {
        return this.logTimeFunctionByLevel(Level.Warn, message, fn);
    }
    warnTimeAsyncFunction(message, fn) {
        return this.logTimeAsyncFunctionByLevel(Level.Warn, message, fn);
    }
    errorTimeFunction(message, fn) {
        return this.logTimeFunctionByLevel(Level.Error, message, fn);
    }
    errorTimeAsyncFunction(message, fn) {
        return this.logTimeAsyncFunctionByLevel(Level.Error, message, fn);
    }
    fatalTimeFunction(message, fn) {
        return this.logTimeFunctionByLevel(Level.Fatal, message, fn);
    }
    fatalTimeAsyncFunction(message, fn) {
        return this.logTimeAsyncFunctionByLevel(Level.Fatal, message, fn);
    }
    logByLevel(level, message, elapsedTime) {
        if (this.options.level <= level) {
            this.send(level, message, elapsedTime);
        }
    }
    async logByLevelAsync(level, message, elapsedTime) {
        if (this.options.level <= level) {
            await this.sendAsync(level, message, elapsedTime);
        }
    }
    logTimeByLevel(level, message, expression) {
        if (this.options.level <= level) {
            return measureElapsedTime(expression, elapsedTime => this.send(level, message, elapsedTime));
        }
        else {
            return expression();
        }
    }
    async logTimeByLevelAsync(level, message, expression) {
        if (this.options.level <= level) {
            return measureElapsedTimeAsync(expression, elapsedTime => this.sendAsync(level, message, elapsedTime));
        }
        else {
            return await expression();
        }
    }
    logTimeFunctionByLevel(level, message, fn) {
        if (this.options.level <= level) {
            return (...args) => {
                return measureElapsedTime(() => fn(...args), elapsedTime => this.send(level, message, elapsedTime));
            };
        }
        else {
            return fn;
        }
    }
    logTimeAsyncFunctionByLevel(level, message, fn) {
        if (this.options.level <= level) {
            return (...args) => {
                return measureElapsedTimeAsync(() => fn(...args), elapsedTime => this.sendAsync(level, message, elapsedTime));
            };
        }
        else {
            return async (...args) => await fn(...args);
        }
    }
    send(level, message, elapsedTime) {
        this.options.transport.send({
            level,
            message: getValue(message),
            namespace: this.options.namespace,
            timestamp: Date.now(),
            elapsedTime
        });
    }
    async sendAsync(level, message, elapsedTime) {
        return this.send(level, await getValue(message), elapsedTime);
    }
}
//# sourceMappingURL=logger.js.map