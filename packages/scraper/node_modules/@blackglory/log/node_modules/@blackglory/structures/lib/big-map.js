export class BigMap {
    constructor() {
        this._maps = [];
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    get size() {
        return this._maps
            .map(map => map.size)
            .reduce((acc, cur) => acc + cur, 0);
    }
    *[Symbol.iterator]() {
        for (const map of this._maps) {
            yield* map[Symbol.iterator]();
        }
    }
    set(key, value) {
        {
            const map = this._maps.find(map => map.has(key));
            if (map) {
                map.set(key, value);
                return;
            }
        }
        for (const map of this._maps) {
            try {
                map.set(key, value);
                return;
            }
            catch (e) {
                if (e instanceof RangeError)
                    continue;
                throw e;
            }
        }
        const map = new Map();
        map.set(key, value);
        this._maps.push(map);
    }
    has(key) {
        return this._maps.some(set => set.has(key));
    }
    get(key) {
        for (const map of this._maps) {
            if (map.has(key)) {
                return map.get(key);
            }
        }
    }
    delete(key) {
        for (const [index, map] of this._maps.entries()) {
            if (map.has(key)) {
                map.delete(key);
                if (map.size === 0) {
                    this._maps.splice(index, 1);
                }
                return true;
            }
        }
        return false;
    }
    clear() {
        this._maps = [];
    }
    *entries() {
        for (const map of this._maps) {
            yield* map.entries();
        }
    }
    *keys() {
        for (const map of this._maps) {
            yield* map.keys();
        }
    }
    *values() {
        for (const map of this._maps) {
            yield* map.values();
        }
    }
}
//# sourceMappingURL=big-map.js.map