export class BigSet {
    _sets = [];
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    get size() {
        return this._sets
            .map(set => set.size)
            .reduce((acc, cur) => acc + cur, 0);
    }
    *[Symbol.iterator]() {
        for (const set of this._sets) {
            yield* set[Symbol.iterator]();
        }
    }
    add(value) {
        if (this._sets.some(set => set.has(value)))
            return;
        for (const set of this._sets) {
            try {
                set.add(value);
                return;
            }
            catch (e) {
                if (e instanceof RangeError)
                    continue;
                throw e;
            }
        }
        const set = new Set();
        set.add(value);
        this._sets.push(set);
    }
    has(value) {
        return this._sets.some(set => set.has(value));
    }
    delete(value) {
        for (const [index, set] of this._sets.entries()) {
            if (set.has(value)) {
                set.delete(value);
                if (set.size === 0) {
                    this._sets.splice(index, 1);
                }
                return true;
            }
        }
        return false;
    }
    clear() {
        this._sets = [];
    }
    *values() {
        for (const set of this._sets) {
            yield* set.values();
        }
    }
}
//# sourceMappingURL=big-set.js.map