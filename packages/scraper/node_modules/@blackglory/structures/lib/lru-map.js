import { assert } from '@blackglory/errors';
import { first } from 'iterable-operator';
export class LRUMap {
    limit;
    map = new Map();
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    get size() {
        return this.map.size;
    }
    constructor(limit) {
        assert(Number.isInteger(limit), 'The parameter limit must be an integer');
        assert(limit > 0, 'The parameter limit must be a positive value');
        this.limit = limit;
    }
    set(key, value) {
        if (this.map.has(key)) {
            this.updateItem(key, value);
        }
        else {
            if (this.map.size === this.limit) {
                this.map.delete(this.getColdestKey());
            }
            this.map.set(key, value);
        }
        return this;
    }
    has(key) {
        return this.map.has(key);
    }
    get(key) {
        if (!this.has(key))
            return undefined;
        const value = this.map.get(key);
        this.updateItem(key, value);
        return value;
    }
    delete(key) {
        return this.map.delete(key);
    }
    clear() {
        this.map.clear();
    }
    updateItem(key, value) {
        this.map.delete(key);
        this.map.set(key, value);
    }
    getColdestKey() {
        return first(this.map.keys());
    }
}
//# sourceMappingURL=lru-map.js.map